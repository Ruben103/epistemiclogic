Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nimport numpy as np\nimport random as rd\n\nclass Game():\n\n    def __init__(self, num_players):\n        self.players = num_players\n        self.players = []\n        self.initialize_players(num_players)\n\n        # keep track of rounds for information retrieval in later stages\n        self.rounds = []\n        self.current_round = Round(self.players, rd.randint(1,num_players))\n\n    def initialize_players(self, num_players):\n        for i in range(1, num_players + 1):\n            self.players.append(Player(name='P' + str(i), game=self))\n\n    def save_round(self, state_of_round):\n        self.rounds.append(state_of_round)\n\n\nclass Round():\n\n    def __init__(self, players, starting_player):\n        # self.game = game\n        self.CK = []\n        self.players = players\n        self.starting_player = starting_player\n        self.num_dice = self.count_dice(self.players)\n\n        self.curr_bid_num = None\n        self.curr_bid_val = None\n\n        self.end_of_bid_phase = False\n\n    def update_CK(self, bid_num, bid_val):\n        \"\"\"\n        This function updates the Common Knowledge base based on the bids of each player per round.\n        Determine probabilistically what the other agents believe the amount\n        of dice should be in the hands of the player making a bid and add that to the knowledge base.\n        This function should also prompt all of the players' knowledge bases\n        :return:\n        \"\"\"\n        pass\n\n    def controller(self, it):\n        \"\"\"\n        Haven't tested yet if the iterator gives segmentation errors yet, but the structure should be smt like this\n        We iterate over players, players return bid. If they don't believe its possible, they set end_of_bid_phase\n        :param it:\n        :return:\n        \"\"\"\n\n        current_player = self.players[it - 1]\n        if not self.end_of_bid_phase:\n\n            bid_num, bid_val = current_player.ask_bid(self.curr_bid_num, self.curr_bid_val)\n            if bid_num == -1 and bid_val == -1:\n                self.end_of_bid_phase = True\n            else:\n                self.update_CK(bid_num, bid_val)\n                self.curr_bid_num = bid_num; self.curr_bid_val = bid_val\n            self.controller(it = it + 1 if it + 1 != len(self.players) else 0)\n        else:\n            for p in self.players:\n                if p.valuation is not None:\n                    current_player.val_bid(self.curr_bid_num, self.curr_bid_val)\n            self.end_of_round()\n\n    def is_possible(self, dice):\n        pass\n\n    def end_of_round(self):\n        dice = []\n        for p in self.players:\n            dice.append(p.dice)\n        valuation = self.is_possible(dice)\n        for i in range(len(self.players)):\n            p = self.players(i)\n            p_eval = p.remove_dice(valuation)\n            if p_eval == True:\n                print(\"Player\", i, \"'s valuation is correct \\n no dice is removed from his stock\")\n            if p_eval == False:\n                print(\"Player\", i, \"'s valuation is false \\n one dice is removed from his stock\")\n        self.save_round(self)\n        self.reset_CK()\n        self.controller(self.starting_player)\n\n    def reset_CK(self):\n        self.CK = []\n\n    def count_dice(self, players):\n        count = 0\n\n        for player in players:\n            count += player.get_num_dice()\n        return count\n\n\nclass Player():\n\n    def __init__(self, name, game):\n        self.name = name\n        self.num_dice = 6\n        self.dice = self.init_dice(self.num_dice)\n        self.KB = []\n        self.update_KB()\n\n        self.curr_bid_num = None\n        self.curr_bid_val = None\n        self.valuation = None\n\n    def init_dice(self, num_dice):\n        dice = []\n        for i in range(num_dice):\n            dice.append(rd.randint(1, 6))\n        return sorted(dice)\n\n    def update_dice(self, new):\n        self.num_dice = new\n\n    def update_KB(self):\n        self.KB = self.dice\n\n    def get_num_dice(self):\n        return self.num_dice\n\n    def is_possible(self, bid_num, bid_val):\n        return True\n\n    def ask_bid(self, bid_num, bid_val):\n        \"\"\"\n        This function makes a bid based on the players KB.\n        The player needs to make a higher offer than the previous one. (Round.curr_bid_num, Round.curr_bid_val).\n        :return: tuple: bid_num, bid_val\n        \"\"\"\n        if self.is_possible(bid_num, bid_val):\n            return 3, 4\n        else:\n            return False, False\n\n    def val_bid(self, bid_num, bid_val):\n        \"\"\"\n        This function is prompted when the bidding phase is over.\n        :param bid_num:\n        :param bid_val:\n        :return: return T/F for whether they believe the current bid is possible or not.\n        \"\"\"\n        pass\n\nif __name__ == '__main__':\n    game = Game(num_players=4)\n    game.current_round.controller(game.current_round.starting_player)\n\n    print(\"BUGSTOPPER\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.py	(revision b64a74c06f438c7d5e06752224fa24f2aff58284)
+++ main.py	(date 1591020220795)
@@ -1,6 +1,8 @@
 import os
 import numpy as np
 import random as rd
+from flask_restful import Resource
+
 
 class Game():
 
@@ -150,6 +152,13 @@
         """
         pass
 
+
+class playGame(Resource):
+    game = Game(num_players=4)
+    game.current_round.controller(game.current_round.starting_player)
+
+    print("BUGSTOPPER")
+
 if __name__ == '__main__':
     game = Game(num_players=4)
     game.current_round.controller(game.current_round.starting_player)
Index: WebInterface/app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from flask import Flask\nfrom flask_restful import Resource, Api\nimport time\n\napp = Flask(__name__)\napi = Api(app)\n\n\nclass HelloWorld(Resource):\n    def get(self):\n        return {'DateTime': time.time()}\n\n\napi.add_resource(HelloWorld, '/')\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0')\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- WebInterface/app.py	(revision b64a74c06f438c7d5e06752224fa24f2aff58284)
+++ WebInterface/app.py	(date 1591020128007)
@@ -1,6 +1,7 @@
-from flask import Flask
+from flask import Flask, request
 from flask_restful import Resource, Api
 import time
+from main import playGame
 
 app = Flask(__name__)
 api = Api(app)
@@ -12,6 +13,7 @@
 
 
 api.add_resource(HelloWorld, '/')
+api.add_resource(playGame, '/start')
 
 if __name__ == '__main__':
     app.run(debug=True, host='0.0.0.0')
